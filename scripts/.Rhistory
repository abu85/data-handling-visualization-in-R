# install.packages("plotrix")  # if not installed
## Build percentage vectors per source
counts_x <- combined_data %>%
filter(!is.na(Education_Level.x), Education_Level.x != "") %>%
count(Education_Level.x, name = "n") %>%
mutate(pct = n / sum(n))
counts_y <- combined_data %>%
filter(!is.na(Education_Level.y), Education_Level.y != "") %>%
count(Education_Level.y, name = "n") %>%
mutate(pct = n / sum(n))
## Create a shared set of categories (legend entries) and consistent colors
all_lvls <- sort(unique(c(counts_x$Education_Level.x, counts_y$Education_Level.y)))
# Choose a palette with enough distinct colors (no extra package required)
cols <- setNames(grDevices::hcl.colors(length(all_lvls), palette = "Set2"), all_lvls)
## Map colors for each pie in the same order as the data vectors
col_x <- cols[counts_x$Education_Level.x]
col_y <- cols[counts_y$Education_Level.y]
## Layout: 2 rows — top row for legend (short), bottom row for the two pies
layout(
matrix(c(1, 1, 2, 3), nrow = 2, byrow = TRUE),  # top spans two columns
heights = c(1, 5)                                # make top row shorter
)
par(mar = c(0, 0, 2, 0))  # small margins for legend row
plot.new()
legend(
"center",
legend = all_lvls,
fill = cols[all_lvls],
ncol = min(length(all_lvls), 3),  # wrap legend into columns if many levels
bty = "n",
title = "শিক্ষাগত যোগ্যতা"
)
## Now draw the two pies in the bottom row
par(mar = c(2, 4, 4, 2))  # margins for the pies
# Left pie: Education_Level.x
pie3D(
counts_x$pct,
labels = scales::percent(counts_x$pct, accuracy = 0.1),
explode = 0.05,
main = "জামায়াত",
labelcex = 0.9,
start = 0,
col = col_x
)
# Right pie: Education_Level.y
pie3D(
counts_y$pct,
labels = scales::percent(counts_y$pct, accuracy = 0.1),
explode = 0.05,
main =  "বিএনপি",
labelcex = 0.9,
start = 0,
col = col_y
)
# (Optional) Reset layout
layout(1)
# উদাহরণ (আপনার প্রকৃত ক্যাটেগরি অনুযায়ী ম্যাপ করুন)
lvl_map <- c(
"No formal education" = "কোনো আনুষ্ঠানিক শিক্ষা নেই",
"Primary"             = "প্রাথমিক",
"Secondary"           = "মাধ্যমিক",
"Higher Secondary"    = "উচ্চ মাধ্যমিক",
"Bachelor"            = "স্নাতক",
"Masters"             = "স্নাতকোত্তর",
"PhD"                 = "পিএইচডি"
)
# all_lvls কে বাংলা করুন (যা ম্যাপে আছে সেগুলো রূপান্তর হবে)
all_lvls_bn <- ifelse(all_lvls %in% names(lvl_map), lvl_map[all_lvls], all_lvls)
# counts_x / counts_y-এর লেবেল অর্ডার অনুযায়ী বাংলা টেক্সটও চাইলে:
lab_cat_x <- ifelse(counts_x$Education_Level.x %in% names(lvl_map),
lvl_map[counts_x$Education_Level.x],
counts_x$Education_Level.x)
lab_cat_y <- ifelse(counts_y$Education_Level.y %in% names(lvl_map),
lvl_map[counts_y$Education_Level.y],
counts_y$Education_Level.y)
# 1) ইংরেজি -> বাংলা ডিজিট কনভার্টার
to_bangla_digits <- function(x) {
s <- as.character(x)
en <- c("0","1","2","3","4","5","6","7","8","9",".","%")
bn <- c("০","১","২","৩","৪","৫","৬","৭","৮","৯",".","%")  # ডট আগের মতোই রাখলাম
for (i in seq_along(en)) s <- gsub(en[i], bn[i], s, fixed = TRUE)
s
}
# 2) আপনার ডেটা প্রস্তুতি
counts_x <- combined_data %>%
filter(!is.na(Education_Level.x), Education_Level.x != "") %>%
count(Education_Level.x, name = "n") %>%
mutate(pct = n / sum(n))
counts_y <- combined_data %>%
filter(!is.na(Education_Level.y), Education_Level.y != "") %>%
count(Education_Level.y, name = "n") %>%
mutate(pct = n / sum(n))
# 3) শেয়ার্ড লেজেন্ড কালার
all_lvls <- sort(unique(c(counts_x$Education_Level.x, counts_y$Education_Level.y)))
cols <- setNames(grDevices::hcl.colors(length(all_lvls), palette = "Set2"), all_lvls)
col_x <- cols[counts_x$Education_Level.x]
col_y <- cols[counts_y$Education_Level.y]
# (ঐচ্ছিক) ইংরেজি -> বাংলা ক্যাটেগরি ম্যাপ
# lvl_map <- c("Primary"="প্রাথমিক", "Secondary"="মাধ্যমিক", ...)
# all_lvls_bn <- ifelse(all_lvls %in% names(lvl_map), lvl_map[all_lvls], all_lvls)
# lab_cat_x  <- ifelse(counts_x$Education_Level.x %in% names(lvl_map),
#                      lvl_map[counts_x$Education_Level.x], counts_x$Education_Level.x)
# lab_cat_y  <- ifelse(counts_y$Education_Level.y %in% names(lvl_map),
#                      lvl_map[counts_y$Education_Level.y], counts_y$Education_Level.y)
# আপাতত ক্যাটেগরি যেমন আছে তেমনই রাখছি
all_lvls_bn <- all_lvls
# 4) শতাংশ লেবেলকে বাংলা অঙ্কে
lab_x <- to_bangla_digits(scales::percent(counts_x$pct, accuracy = 0.1))
lab_y <- to_bangla_digits(scales::percent(counts_y$pct, accuracy = 0.1))
# 5) লেআউট + লেজেন্ড + পাই
layout(
matrix(c(1, 1, 2, 3), nrow = 2, byrow = TRUE),
heights = c(1, 5)
)
par(mar = c(0, 0, 2, 0))
plot.new()
legend(
"center",
legend = lvl_map,          # এখানে বাংলা কেটেগরি লাগলে all_lvls_bn দিন
fill   = cols[all_lvls],
ncol   = min(length(all_lvls), 3),
bty    = "n",
title  = "শিক্ষাগত যোগ্যতা"
)
par(mar = c(2, 4, 4, 2))  # pies
# Left pie: Education_Level.x
pie3D(
counts_x$pct,
labels   = lab_x,              # বাংলা অঙ্ক সহ শতাংশ
explode  = 0.05,
main     = "জামায়াত",
labelcex = 0.9,
start    = 0,
col      = col_x
)
# Right pie: Education_Level.y
pie3D(
counts_y$pct,
labels   = lab_y,              # বাংলা অঙ্ক সহ শতাংশ
explode  = 0.05,
main     = "বিএনপি",
labelcex = 0.9,
start    = 0,
col      = col_y
)
layout(1)
library(sysfonts)
library(showtext)    # বাংলা ফন্ট সুন্দরভাবে দেখাতে (ঐচ্ছিক)
ggplot(df_age, aes(x = log10(`6. Yearly total income (Candidate)`) , y = log10(`7. Yearly total income (Wife)`))) +
geom_point(aes(colour = `5. Education qualification`)) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
# geom_text(aes(label = Seat), vjust = -0.8, size = 2) +
# geom_text_repel(aes(label = `5. Education qualification`, colour = `5. Education qualification`), size = 2, max.overlaps = Inf) +
labs(title = "Candiate Income VS Wife income ",
x = "Candidate income (log10)", y = "Wife income (log10)",caption = "- ABSB") +
theme_minimal(base_size = 12) +
theme(
plot.title   = element_text(size = 22, face = "bold"),
axis.title.y = element_text(size = 18, face = "bold"),
axis.text.y  = element_text(size = 16),
axis.text.x  = element_text(size = 16),
plot.caption = element_text(size = 8, face = "italic", color = "gray30"),
legend.position = "none"
)
ggplot(df_age, aes(x = log10(`6. Yearly total income (Candidate)`) , y = log10(`7. Yearly total income (Wife)`))) +
geom_point(aes(colour = `5. Education qualification`)) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
# geom_text(aes(label = Seat), vjust = -0.8, size = 2) +
geom_text_repel(aes(label = `5. Education qualification`, colour = `5. Education qualification`), size = 2, max.overlaps = Inf) +
labs(title = "Candiate Income VS Wife income ",
x = "Candidate income (log10)", y = "Wife income (log10)",caption = "- ABSB") +
theme_minimal(base_size = 12) +
theme(
plot.title   = element_text(size = 22, face = "bold"),
axis.title.y = element_text(size = 18, face = "bold"),
axis.text.y  = element_text(size = 16),
axis.text.x  = element_text(size = 16),
plot.caption = element_text(size = 8, face = "italic", color = "gray30"),
legend.position = "none"
)
ggplot(df_age, aes(x = `4. Profession` , y = log10(`7. Yearly total income (Wife)`))) +
geom_point() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
gap_long <- gap_wide %>%
pivot_longer(
cols = c(-continent, -country),
names_to = "obstype_year", values_to = "obs_values"
)
#| echo: false
#| output: asis
cat("# ","Overview")
gapminder <- read.csv("data/gapminder_data.csv", header = TRUE, stringsAsFactors = FALSE)
gap_wide <- read.csv("data/gapminder_wide.csv", header = TRUE, stringsAsFactors = FALSE)
library("tidyr")
library("dplyr")
gapminder <- read.csv("https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/main/episodes/data/gapminder_data.csv")
head(gapminder)
# or str(gapminder)
# or View(gapminder)
gap_wide <- read.csv("https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/data/gapminder_wide.csv", stringsAsFactors = FALSE)
str(gap_wide)
gap_long <- gap_wide %>%
pivot_longer(
cols = c(starts_with('pop'), starts_with('lifeExp'), starts_with('gdpPercap')),
names_to = "obstype_year", values_to = "obs_values"
)
str(gap_long)
gap_long <- gap_wide %>%
pivot_longer(
cols = c(-continent, -country),
names_to = "obstype_year", values_to = "obs_values"
)
tail(gap_long)
head(gap_long)
gap_long <- gap_long %>% separate(obstype_year, into = c('obs_type', 'year'), sep = "_")
gap_long$year <- as.integer(gap_long$year)
gap_normal <- gap_long %>%
pivot_wider(names_from = obs_type, values_from = obs_values)
dim(gap_normal)
dim(gapminder)
names(gap_normal)
names(gapminder)
gap_normal <- gap_normal[, names(gapminder)]
all.equal(gap_normal, gapminder)
head(gap_normal)
head(gapminder)
all.equal(gap_normal, gapminder)
gap_temp <- gap_long %>% unite(var_ID, continent, country, sep = "_")
str(gap_temp)
gap_temp <- gap_long %>%
unite(ID_var, continent, country, sep = "_") %>%
unite(var_names, obs_type, year, sep = "_")
str(gap_temp)
gap_wide_new <- gap_long %>%
unite(ID_var, continent, country, sep = "_") %>%
unite(var_names, obs_type, year, sep = "_") %>%
pivot_wider(names_from = var_names, values_from = obs_values)
str(gap_wide_new)
gap_ludicrously_wide <- gap_long %>%
unite(var_names, obs_type, year, country, sep = "_") %>%
pivot_wider(names_from = var_names, values_from = obs_values)
gap_wide_betterID <- separate(gap_wide_new, ID_var, c("continent", "country"), sep="_")
gap_wide_betterID <- gap_long %>%
unite(ID_var, continent, country, sep = "_") %>%
unite(var_names, obs_type, year, sep = "_") %>%
pivot_wider(names_from = var_names, values_from = obs_values) %>%
separate(ID_var, c("continent","country"), sep = "_")
str(gap_wide_betterID)
all.equal(gap_wide, gap_wide_betterID)
sessionInfo()
gap_long <- gap_long %>%
separate(obstype_year, into = c('obs_type', 'year'), sep = "_")
tail(gap_long)
library(tidyr)
gap_long <- gap_long %>%
separate(obstype_year, into = c('obs_type', 'year'), sep = "_")
View(gap_long)
#| echo: false
#| output: asis
cat("# ","Overview")
gapminder <- read.csv("data/gapminder_data.csv", header = TRUE, stringsAsFactors = FALSE)
gap_wide <- read.csv("data/gapminder_wide.csv", header = TRUE, stringsAsFactors = FALSE)
library("tidyr")
library("dplyr")
gapminder <- read.csv("https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/main/episodes/data/gapminder_data.csv")
head(gapminder)
# or str(gapminder)
# or View(gapminder)
gap_wide <- read.csv("https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/data/gapminder_wide.csv", stringsAsFactors = FALSE)
str(gap_wide)
gap_long <- gap_wide %>%
pivot_longer(
cols = c(starts_with('pop'), starts_with('lifeExp'), starts_with('gdpPercap')),
names_to = "obstype_year", values_to = "obs_values"
)
str(gap_long)
gap_long <- gap_wide %>%
pivot_longer(
cols = c(-continent, -country),
names_to = "obstype_year", values_to = "obs_values"
)
head(gap_long)
tail(gap_long)
gap_long <- gap_long %>%
separate(obstype_year, into = c('obs_type', 'year'), sep = "_")
gap_long$year <- as.integer(gap_long$year)
gap_long <- gap_long %>%
separate(obstype_year, into = c('obs_type', 'year'), sep = "_")
gap_long <- gap_long %>%
separate(obstype_year, into = c('obs_type', 'year'), sep = "_")
#| echo: false
#| output: asis
cat("# ","Overview")
gapminder <- read.csv("data/gapminder_data.csv", header = TRUE, stringsAsFactors = FALSE)
gap_wide <- read.csv("data/gapminder_wide.csv", header = TRUE, stringsAsFactors = FALSE)
library("tidyr")
library("dplyr")
gapminder <- read.csv("https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/main/episodes/data/gapminder_data.csv")
head(gapminder)
# or str(gapminder)
# or View(gapminder)
gap_wide <- read.csv("https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/data/gapminder_wide.csv", stringsAsFactors = FALSE)
str(gap_wide)
gap_long <- gap_wide %>%
pivot_longer(
cols = c(starts_with('pop'), starts_with('lifeExp'), starts_with('gdpPercap')),
names_to = "obstype_year", values_to = "obs_values"
)
str(gap_long)
gap_long <- gap_wide %>%
pivot_longer(
cols = c(-continent, -country),
names_to = "obstype_year", values_to = "obs_values"
)
head(gap_long)
tail(gap_long)
gap_wide <- read.csv("https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/data/gapminder_wide.csv", stringsAsFactors = FALSE)
head(gap_wide)
gap_long <- gap_wide %>%
pivot_longer(
cols = c(starts_with('pop'), starts_with('lifeExp'), starts_with('gdpPercap')),
names_to = "obstype_year", values_to = "obs_values"
)
head(gap_long)
gapminder %>%
# extract first letter of country name into new column
mutate(startsWith = substr(country, 1, 1)) %>%
# only keep countries starting with A or Z
filter(startsWith %in% c("A", "Z")) %>%
# plot lifeExp into facets
ggplot(aes(x = year, y = lifeExp, colour = continent)) +  # x and y and set color
geom_line() +                                             # line plot
facet_wrap(vars(country)) +                               # split the plot
theme_minimal()                                           # set theme
# ------------------------------------------------------------------------------
# Goal: Calculate GDP (in billions), population, and GDP-per-capita summaries
#       for each continent and year — but only for countries whose life
#       expectancy is above 25. This demonstrates conditional variable creation
#       and grouped summaries.
# ------------------------------------------------------------------------------
gdp_pop_bycontinents_byyear_above25 <- gapminder %>%
# We create a new variable 'gdp_billion'. However, we only want this value
# for countries with reasonably high data quality, symbolized here by
# life expectancy > 25 years.
#
# If the condition is TRUE → compute GDP in billions.
# If the condition is FALSE → assign NA so these rows won't affect summary stats.
mutate(gdp_billion = ifelse(lifeExp > 25,
gdpPercap * pop / 10^9,   # convert to billions
NA)) %>%
# Now we want to understand patterns at a broader scale — by continent and year.
# 'group_by()' tells R to calculate upcoming summaries within these groups.
group_by(continent, year) %>%
# Summaries: mean and standard deviation help us capture both central trends
# (mean) and data variability (sd). Using 'mean()' on variables that contain NA
# will automatically ignore NAs unless 'na.rm = TRUE' is set explicitly,
# but because our data has NAs only for gdp_billion, the behavior is appropriate.
summarize(mean_gdpPercap = mean(gdpPercap),
sd_gdpPercap = sd(gdpPercap),
mean_pop = mean(pop),
sd_pop = sd(pop),
mean_gdp_billion = mean(gdp_billion, na.rm = TRUE),
sd_gdp_billion = sd(gdp_billion, na.rm = TRUE))
# ------------------------------------------------------------------------------
# Goal: Estimate a “future” GDP per capita value for each country, where
#       countries with higher life expectancy (>40) are expected to see
#       greater economic growth. We artificially scale those GDPs as an example.
# ------------------------------------------------------------------------------
gdp_future_bycontinents_byyear_high_lifeExp <- gapminder %>%
# Here we introduce the idea of conditional adjustments — when life expectancy
# is high (>40), we assume the country may experience stronger future growth.
#
# We multiply GDP per capita by 1.5 for those countries. Otherwise, we keep
# the original GDP value. This is a simple model but a powerful learning tool.
mutate(gdp_futureExpectation = ifelse(lifeExp > 40,
gdpPercap * 1.5,
gdpPercap)) %>%
# Again, grouping by continent and year allows us to compare patterns across
# regions and time, rather than country by country.
group_by(continent, year) %>%
# Finally, we calculate the average current GDP per capita and the average
# expected GDP value we just computed. This lets us see whether continents
# with higher life expectancy also show larger "future" GDP shifts.
summarize(mean_gdpPercap = mean(gdpPercap),
mean_gdpPercap_expected = mean(gdp_futureExpectation))
``
# ------------------------------------------------------------------------------
# Goal: Calculate GDP (in billions), population, and GDP-per-capita summaries
#       for each continent and year — but only for countries whose life
#       expectancy is above 25. This demonstrates conditional variable creation
#       and grouped summaries.
# ------------------------------------------------------------------------------
gdp_pop_bycontinents_byyear_above25 <- gapminder %>%
# We create a new variable 'gdp_billion'. However, we only want this value
# for countries with reasonably high data quality, symbolized here by
# life expectancy > 25 years.
#
# If the condition is TRUE → compute GDP in billions.
# If the condition is FALSE → assign NA so these rows won't affect summary stats.
mutate(gdp_billion = ifelse(lifeExp > 25,
gdpPercap * pop / 10^9,   # convert to billions
NA)) %>%
# Now we want to understand patterns at a broader scale — by continent and year.
# 'group_by()' tells R to calculate upcoming summaries within these groups.
group_by(continent, year) %>%
# Summaries: mean and standard deviation help us capture both central trends
# (mean) and data variability (sd). Using 'mean()' on variables that contain NA
# will automatically ignore NAs unless 'na.rm = TRUE' is set explicitly,
# but because our data has NAs only for gdp_billion, the behavior is appropriate.
summarize(mean_gdpPercap = mean(gdpPercap),
sd_gdpPercap = sd(gdpPercap),
mean_pop = mean(pop),
sd_pop = sd(pop),
mean_gdp_billion = mean(gdp_billion, na.rm = TRUE),
sd_gdp_billion = sd(gdp_billion, na.rm = TRUE))
# ------------------------------------------------------------------------------
# Goal: Estimate a “future” GDP per capita value for each country, where
#       countries with higher life expectancy (>40) are expected to see
#       greater economic growth. We artificially scale those GDPs as an example.
# ------------------------------------------------------------------------------
gdp_future_bycontinents_byyear_high_lifeExp <- gapminder %>%
# Here we introduce the idea of conditional adjustments — when life expectancy
# is high (>40), we assume the country may experience stronger future growth.
#
# We multiply GDP per capita by 1.5 for those countries. Otherwise, we keep
# the original GDP value. This is a simple model but a powerful learning tool.
mutate(gdp_futureExpectation = ifelse(lifeExp > 40,
gdpPercap * 1.5,
gdpPercap)) %>%
# Again, grouping by continent and year allows us to compare patterns across
# regions and time, rather than country by country.
group_by(continent, year) %>%
# Finally, we calculate the average current GDP per capita and the average
# expected GDP value we just computed. This lets us see whether continents
# with higher life expectancy also show larger "future" GDP shifts.
summarize(mean_gdpPercap = mean(gdpPercap),
mean_gdpPercap_expected = mean(gdp_futureExpectation))
cases <- read_csv(ttps://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv?raw=true)
cases <- read_csv(https://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv?raw=true)
cases <- read_csv("https://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv?raw=true")
cases <- read_csv("https://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv?raw=true")
View(cases)
str(cases)
cases
cases <- read_csv("https://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv?raw=true")
cases <- read_csv("https://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv")
cases
cases <- read_csv("https://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv?")
cases <- read_csv("https://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv?raw=true")
spec(cases)
cases
cases_raw <- https://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv?raw=true
cases_raw <- https://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv?raw=true
cases_raw <- https://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv?raw=true
cases_raw <- "https://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv?raw=true"
cases <- read_csv(cases_raw)
cases
spec(cases)
cases <- read_csv( "https://github.com/rstudio/EDAWR/blob/master/data-raw/cases.csv?raw=true")
pivot_longer(
cases,
cols = starts_with("20"),
names_to = "year",
values_to = "n")
pivot_longer(
cases,
cols = ,
names_to = "year",
values_to = "n")
pivot_longer(
cases,
cols,
names_to = "year",
values_to = "n")
pivot_longer(
cases,
cols,
names_to = "year",
values_to = "n")
cases
pivot_longer(
cases,
!country,
names_to = "year",
values_to = "n")
pivot_longer(
cases,
everything(),
names_to = "year",
values_to = "n")
pivot_longer(
cases,
!country,
names_to = "year",
values_to = "n")
pivot_longer(
cases,
cols = !country,
names_to = "year",
values_to = "n")
pivot_longer(
cases,
cols = !country,
names_to = "year",
values_to = "n")
cases | !country
cases %>%  !country
cases %>% !country
cases %>% !country
?gapminder
??gapminder
setwd("C:/Users/auue0001/OneDrive - Sveriges lantbruksuniversitet/slubi/proj/2026/gs_vms_course/data_handling_visualization/scripts")
